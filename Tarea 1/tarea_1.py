# -*- coding: utf-8 -*-
"""Tarea_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P-B8UFjG3ulnH1LHXzcgDp7sQZ9MsNaX

EAE3709 APLICACIONES DE  MACHINE LEARNING EN ECONOMÍA <br>
1ER SEMESTRE 2025 <br>
INSTITUTO DE ECONOMÍA <br>
PONTIFICIA UNIVERSIDAD CATÓLICA DE CHILE


# **TAREA 1**


---


Profesor:
- Joaquín Pérez Lapillo

Ayudantes:

- Luis García B.
- Sebastián Hernández B.
- Oscar Herrera G.

**Complete sus datos:**

- Nombre y apellido:
  - Xiomara Kuwae
  - Luis José López 28.230.426-0
- Usuario de GitHub (opcional):  https://github.com/luijolo ->

## Instrucciones

- Descargue el notebook y cárguelo en su Drive.
- Todas las preguntas deben ser contestadas en su notebook.
- Para que una pregunta esté correcta el código debe correr.
- Si es necesario, realice comentarios breves en su código explicando lo que está realizando o sus resultados.
- Una vez culminada su tarea, suba su notebook al buzón de tareas de Canvas.
- La fecha y hora límite de esta tarea es el _**viernes 4 de abril a las 18:00 hrs**_.

### Distribución de puntaje


| Pregunta                        | Puntaje |
|--------------------------------|---------|
| Pregunta 1.0                   |    1    |
| Pregunta 1.1                   |    3    |
| Pregunta 1.2                   |    3    |
| Pregunta 1.3                   |    2    |
| Pregunta 1.4                   |    2    |
| Pregunta 1.5                   |    5    |
| Pregunta 1.6                   |    2    |
| Pregunta 1.7                   |    5    |
| Pregunta 1.8                   |   7    |
| Pregunta 1.9                   |   5    |
| Pregunta 1.10                  |   5    |
| Pregunta 1.11                  |   6    |
| Pregunta 1.12                  |    2    |
| Pregunta 1.13                  |    5    |
| Pregunta 1.14                  |   10    |
| Pregunta 1.15                  |    5    |
| Pregunta 1.16                  |    5    |
| Pregunta 2.0                   |    2    |
| Pregunta 2.1                   |    5    |
| Pregunta 2.2                   |    5    |
| Pregunta 2.3                   |    5    |
| Pregunta 2.4                   |    3    |
| Pregunta 2.5                   |    3    |
| Pregunta 2.6                   |    2    |
| Pregunta 2.7                   |    2    |

Total: 100 pts.

### Sobre el Bonus

- La entrega, por defecto, es a través de Canvas. Sin embargo, puede escoger voluntariamente entregar la tarea en su GitHub personal.

- Si usted realiza la entrega en GitHub antes de la **fecha y hora indicada**, entonces tendrá una bonificación de 0.3 en su nota final de tarea. Es decir, si usted obtuvo una nota de 6.5, pero entregó en su GitHub, entonces su calificación en esta tarea será de 6.8.

- Si **además** de realizar la entrega a través de GitHub, usted logra crear `branches` (ramas) y realizar un `merge` entre ramas, entonces se le bonificará con 0.5 en su nota de tarea. Es decir, si usted obtuvo una nota de 6.5, pero entregó en su GitHub e hizo el trabajo de ramas, entonces su calificación en esta tarea será de 7.0.

  - Se valora capacidad autodidacta.
  - Sólo serán considerados los archivos contenidos en su rama principal a la fecha y hora indicada.

## Exploratory data analysis (EDA)

Para esta tarea se utilizará como principal fuente de información un dataset con una serie de características económicas, demográficas y de desarrollo humano de distintos países a la fecha de 2007 (corte transversal). El dataset está disponible en el siguiente [Github](https://raw.githubusercontent.com/lfgarcia-1/EAE3709-1-2025/refs/heads/main/economic_dataset.csv).<br>

Descripción del dataset:

Variables:

*   date: Fecha en la que se actualizó la data.
*   Population, Area (sq. mi.) Pop. Density (per sq. mi.), Coastline (coast/area ratio), Net migration, Infant mortality (per 1000 births), GDP ($ per capita, Literacy (%), Phones (per 1000), Arable (%), Crops (%), Other (%), Climate, Birthrate, Deathrate, Agriculture, Industry, Service: Características del país.
*   source: fuente de los datos.
*   Region: Región (grupo de países).
*   Country: País.

### Pregunta 1.0

Importe las librerías que usará en su tarea.
"""

# Librerías manejo de datos
import pandas as pd
import numpy as np

# Librerías para graficar
import matplotlib.pyplot as plt
import seaborn as sns

# Librería que filtra warnings innecesarios
import warnings
warnings.filterwarnings("ignore")

"""### Pregunta 1.1

Importe el dataset como un DataFrame (df) directamente desde Github (es decir, no descargue el archivo manualmente). A lo largo de la tarea este df se denominará como `df`.

"""

url = "https://raw.githubusercontent.com/lfgarcia-1/EAE3709-1-2025/refs/heads/main/economic_dataset.csv"
df = pd.read_csv(url)

"""### Pregunta 1.2

Utilice las funciones de Pandas `head()`, `tail()`, `info()` y la propiedad (o atributo) `.dtypes` para describir el `df`. Explique brevemente para qué sirve cada función.
"""

# La función head() permite visualizar las primeras filas de un DataFrame. De no especificar un número, se muestran las primeras 5 filas por defecto.
df.head()

# La función tail() permite mostrar las últimas filas de un DataFrame. De no especificar un número, se muestran las últimas 5 filas por defecto.
df.tail()

# La función info() entrega una breve descripción del DataFrame.
# Describe número de filas y columnas, nombres de las comunas y tipo de datos, número de valores no nulos en cada columna y uso de la memoria del df.
df.info()

# La propiedad .dtypes permite conocer la estructura de los datos, mostrando el tipo de datos de cada columna.
df.dtypes

"""### Pregunta 1.3

La variable `source` es innecesaria debido que contiene el mismo valor para todas las observaciones. Elimine esta variable de su `df`.
"""

del df["source"]

"""### Pregunta 1.4

Transforme el tipo de la variable `date` a `datetime` _datatype_.
"""

# Transformar la variable "date" a tipo datetime sobreescribiendo la columna.
df["date"] = pd.to_datetime(df["date"])

"""### Pregunta 1.5

Para determinar si las variables son "útiles" y sus valores son "correctos" es necesario comprender cada uno de los atributos del dataset.
Investigue y explique brevemente la relación **teórica** entre el `GDP (% per capita)` y cada una de las variables denominadas como "Características del país" en la introducción.

Ejemplo: Existe una variable denominada `Coastline (coast/area ratio)`. Coastline es una medida de la cantidad de costa (acceso a mar) del país normalizada al área total del país para no beneficiar a países más grandes pero con la misma proporción de costa. A mayor "Costline" aumenta la capacidad portuaria per capita del país, más puertos facilita el comercio y podría aumentar el GDP per cápita.

---

A continuación se explicará la relación teórica entre las características de los países y el PIB per capita:

*   **Population**: Existen dos fuerzas que van en sentidos opuestos y que harían que la relación entre el tamaño de la población y el ingreso per cápita no sea claro. Por un lado, más personas puede significar más y mayor progreso tecnológico, mientras que, por otro lado, implica que recursos limitados deben compartirse entre más personas [(Eden & Kuruc, 2023)](https://sites.utexas.edu/pwi/files/2023/08/eden_kuruc_pwisite.pdf).

*   **Area**: La relación entre la superficie de un país y el PIB per cápita no es clara. Por un lado, una superficie mayor, puede significar una mayor probabilidad de encontrar recursos naturales y de tener mayor superficie para destinarlo a diversas actividades económicas. Por otro lado, una mayor superficie puede implicar que algunos costos tales como de ciertos servicios públicos y transporte tengan un valor más elevado [(Alouini & Hubert, 2019)](https://sciencespo.hal.science/hal-03403618v1/file/2019-alouini-country-size-economic-performance-and-volatility.pdf).

*   **Arable**, **Crops**, **Others**, **Agriculture**, **Industry** & **Service**: : Respecto al uso del suelo, el dataframe presenta 3 variables a modo de clasificación: arado, cultivos y otros. Además, para clasificar participación en la actividad económica, se distinguen 3 sectores: agricultura, industria y servicios. Por un lado, la superficie utilizada para arado representa la tierra apta para el cultivo temporal, mientras que la variable crops representa la tierra destinada a cultivo permanente [(Destatis, s.f.)](https://www.destatis.de/EN/Themes/Countries-Regions/International-Statistics/Glossary/ArableLand_c.html). Debido a que los países menos desarrollados tienden a tener un sector agrícola más relevante, mientras que los países desarrollados tienen una actividad económica más concentrada en el sector de servicios, se debiera esperar una correlación débil o negativa, entre uso de suelo en tierra arable `Arable` y cultivos permanentes `Crops`, y el PIB per cápita [(Norris et al., 2013)](https://www.elibrary.imf.org/view/journals/001/2013/176/article-A001-en.xml?). Por otro lado, como `Others` concentra a todo el demás uso de tierra incluido el urbano, teóricamente, podría existir una relación débil y positiva con el PIB per cápita.

*  **Population Density**: En cuanto a la densidad poblacional, no existe una relación significativa entre esta y el PIB per capita, sin embargo si se ajusta la densidad poblacional por la cantidad de tierra que tiene mejores condiciones geográficas para los seres humanos, [Henderson et al., (2020)](https://www.nber.org/system/files/working_papers/w28070/revisions/w28070.rev0.pdf?utm_source=chatgpt.com) defienden que la relación entre densidad poblacional ajustada y PIB per capita se torna negativa y significativa.

*   **Coastline**: [Jetter et al. (2019)](https://www.sciencedirect.com/science/article/pii/S0165176519301582) estimaron para más de 1,500 regiones en 83 países como impacta la distancia desde la costa y la cantidad de costa que poseen, concluyendo que estar lejos de la costa disminuye el PIB per capita entre 10%-13%, producto de que tener acceso al mar fomenta el comercio con el exterior e impulsa el desarrollo de un sector industrial, sin embargo, el tamaño o cantidad de la costa no resulta relevante ni significativo para medir el PIB per capita.

*   **Net migration**: Diversos estudios han evaluado como impacta la migración sobre los niveles de PIB per capita para múltiples países. [Jaumotte et al. (2016)](https://www.imf.org/en/Publications/Spillover-Notes/Issues/2016/12/31/Impact-of-Migration-on-Income-Levels-in-Advanced-Economies-44343) estiman que un incremento en 1 punto porcentual de la población migrante como porcentaje del total de población, provoca un incremento de 2% en el PIB per capita. Según detallan, esto se debe a que se genera un incremento en la productividad total de los factores gracias a la llegada de capital humano cualificado.

*   **Phones**: [Mensah (2023)](https://documents1.worldbank.org/curated/en/099226107252335243/pdf/IDU0034bb9db08f91048a4091f40cd23e11e3fb2.pdf?utm_source=chatgpt.com) identifica la correlación fuerte y positiva entre teléfonos y PIB per capita, realizando múltiples análisis de como el mayor acceso a teléfonos y servicios de telefonía móvil han sido catalizadores importantes del crecimiento y desarollo económico. Para esto utiliza una proxy del desarrollo económico como la iluminación nocturna de las ciudades (más sobre esto en [Henderson et al., 2011](https://pubs.aeaweb.org/doi/pdfplus/10.1257/aer.101.3.194)).

*   **Climate**: Dado los niveles de temperatura promedio de los países, [Burke et al. (2015)](https://www.nature.com/articles/nature15725) muestran evidencia de que de forma no lineal, las altas temperaturas afectan al crecimiento del PIB per capita, siendo más afectados los países más pobres por ser, en promedio, más calientes. Los autores detallan que producto del cambio climático, en 2100 el cambio climático provocará que en países más pobres (y calientes) el PIB per capita será 77% menor a lo que sería sin cambio climático.

*   **Birthrate**: La relación entre la tasa de natalidad y el PIB per cápita no es clara. Por un lado, ceteris paribus, si nacen más personas, se reparten los ingresos entre más individuos. No obstante, una tasa de natalidad demasiado alta puede ser indicador de países con muy bajos ingresos, donde no existen políticas robustas o información respecto a la planificación familiar [(El-Said, 2025)](https://www.nature.com/articles/d44148-025-00026-3).

*   **Deathrate**: La relación entre la tasa de muerte y el PIB per cápita no es clara. Por un lado, ceteris paribus si mueren más personas, los ingresos de la economía se comparten entre menos individuos, lo que aumenta el PIB per cápita. Sin embargo, por otro lado, una tasa de mortalidad alta podría ser indicador de mortalidad infantil alta, poco acceso a la salud, etc., lo que podría vincularse a países con menos ingresos (bajo PIB per cápita) [(Pei Wen & Qi Cheong, 2024)](https://hrmars.com/papers_submitted/24097/the-relationship-between-literacy-rate-primary-school-enrolment-rate-death-rate-and-gdp-per-capita.pdf).

*   **Infant mortality**: La relación entre mortalidad infantil y el PIB per cápita debiese ser inversa, ya que altas tasas de mortalidad infantil serían un indicador de que existe una falta de acceso a la salud, falta de infraestructura sanitaria y prevalencia de desnutrición infantil. Estas características están asociadas a países con bajos ingresos per cápita [(Bar-Zeev et al., 2013)](https://pmc.ncbi.nlm.nih.gov/articles/PMC3791093/#sec7-0141076813489680).

*   **Literacy**: La tasa de alfabetización debiese correlacionar positivamente con el PIB per cápita. Altas tasas de alfabetización estarían relacionados con mayor productividad y en consecuencia, con el ingreso per cápita de las economías [(Pei Wen & Qi Cheong, 2024)](https://hrmars.com/papers_submitted/24097/the-relationship-between-literacy-rate-primary-school-enrolment-rate-death-rate-and-gdp-per-capita.pdf).



---

### Pregunta 1.6

Calcule estadísticas descriptivas para cada variable numérica.
"""

# La función describe() entrega estadísticas descriptivas para variables numéricas.
df.describe()

"""---


Notar que al observar los datos podemos darnos cuenta de que la variable `Climate` está codificada como variable numérica pese a ser categórica. De este modo, no tendría sentido realizar una interpretación de las estadísticas descriptivas de dicha variable.



---

### Pregunta 1.7

Según corresponda, realice un gráfico de distribución de densidad o histograma para describir 3 variables del `df` que usted crea más relevantes.

¿Por qué es importante analizar las distribuciones de las variables a utilizar en su modelo? Ejemplifique su respuesta con al menos una de las variables del df`.

---



Según la evidencia empírica e intuición económica, las variables más relevantes relacionadas al PIB per cápita serían:

*   1. `Literacy (%)`: La tasa de alfabetización debiese estar positivamente relacionada al PIB per cápita, ya que podría ser un indicador de una mano de obra más productiva.
*   2. `Infant mortality (per 1000 births)`: La mortalidad infantil estaría negativamente relacionada al PIB per cápita, ya que podría indicar una falta de acceso a la salud e infraestructura sanitaria, y tasas importantes de desnutrición infantil.
*   3. `Service`: El sector servicios suele tener una participación relativamente relevante en países más desarrollados, por lo que debería estar positivamente relacionada al PIB per cápita.
"""

variables = [
    ['Literacy (%)', 'Alfabetización (%)', 'Histograma de Alfabetización'],
    ['Infant mortality (per 1000 births)', 'Mortalidad Infantil (por 1000 nacidos)', 'Histograma de Mortalidad Infantil'],
    ['Service', 'Porcentaje en Servicios', 'Histograma de Servicios']]

# Crear figura y subplots
fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(17,5))  # Una columna, tres filas

# Loop para crear cada histograma
for i, (col, xlabel, title) in enumerate(variables):
    data = df[col]
    axes[i].hist(data, color='blue', edgecolor='black')
    axes[i].set_xlabel(xlabel)
    axes[i].set_ylabel('Frecuencia')
    axes[i].set_title(title)

# Ajustar espacios para que no se sobrepongan los textos
plt.tight_layout()

# Mostrar gráfico
plt.show()

"""---


La importancia de analizar la distribución de las variables radica en la necesidad de conocer aspectos relevantes para el estudio que se quiere realizar, por ejemplo: identificar la existencia de datos atípicos, datos faltantes (missing), problemas de medición en los datos (observar valores negativos cuando no corresponden, etc.).

Por ejemplo, en el caso de la variable `Literacy`, medida como el porcentaje de personas del país que saben leer y escribir, si observáramos valores negativos o superiores a 100, podríamos identificar que la base de datos tiene errores. A partir de ello, se tendría que tomar decisiones, respecto a seguir trabajando con los mismos datos, y eliminar o imputar nuevos valores a dichas observaciones, o bien, elegir una base de datos que no presente dichos problemas. No tener en cuenta dichos fenómenos, puede llevarnos a realizar un análisis que nos lleve a interpretaciones incorrectas.

---

### Pregunta 1.8

El df contiene variables con missing values (`NaN`). Impute los `NaN` con el método que estime conveniente, justificando su decisión.

¿Es pertinente eliminar alguna de estas variables? Hágalo si es el caso.
"""

#Creamos una tabla resumen con los NaN en cada columna y ordenada de mayor a menor cantidad de NaN
df.isnull().sum().sort_values(ascending=False)

#Para llenar columnas de clima, crops y other basado en la región del país
columnas_a_llenar = ['Climate','Crops (%)','Other (%)']

for columna in columnas_a_llenar:
    for region in df['Region'].unique():
        #Moda de 'Climate' en cada región
        moda_region = df[df['Region'] == region][columna].mode()

        #Rellenamos los NaN de esa región con la moda
        if not moda_region.empty:
            df.loc[(df['Region'] == region) & (df[columna].isna()), columna] = moda_region.iloc[0]

#Evaluamos la correlación entre variables para entender cual podría aportar más información para imputar NaN
numeric_df = df.select_dtypes(include=['number'])
Corr_Matrix = round(numeric_df.corr(), 2)
print(Corr_Matrix)

#Para llenar missing de "Infant mortality" basado en la tasa de nacimientos "Birthrate"
missing_inf = df[df['Infant mortality (per 1000 births)'].isna()]

for idx, row in missing_inf.iterrows():
    brt_value = row['Birthrate']

    similar_rows4 = df[(df['Birthrate'].notna()) & (abs(brt_value - df['Birthrate']) < 0.5)]

    if not similar_rows4.empty:
        average_inf = similar_rows4['Infant mortality (per 1000 births)'].mean()
        df.at[idx, 'Infant mortality (per 1000 births)'] = average_inf


#Para llenar columnas de basado en la tasas de mortalidad infantil "Infant mortality" similares
columns_to_fill = ['Literacy (%)', 'Agriculture', 'Deathrate', 'Birthrate']

for column in columns_to_fill:
    missing_values = df[df[column].isna()]

    # Identificar observaciones con missing
    for idx, row in missing_values.iterrows():
        infant_mortality_value = row['Infant mortality (per 1000 births)']

        #Observaciones con Infant mortality similar
        similar_rows = df[(df['Infant mortality (per 1000 births)'].notna()) & (abs(df['Infant mortality (per 1000 births)'] - infant_mortality_value) < 0.5)]

        #Rellenar NaN con la media de las observaciones que tengan "infant mortality" similares
        if not similar_rows.empty:
            average_value = similar_rows[column].mean()
            df.at[idx, column] = average_value



#Para llenar missing de "Phones (per 1000)" y "Net migration" basado en el PIB per capita
columns_to_fill2 = ['Phones (per 1000)', 'Net migration']

for column in columns_to_fill2:
    missing_values2 = df[df[column].isna()]

    for idx, row in missing_values2.iterrows():
        GDP_value = row['GDP ($ per capita)']

        similar_rows2 = df[(df['GDP ($ per capita)'].notna()) & (abs(df['GDP ($ per capita)'] - GDP_value) < 500)]

        if not similar_rows2.empty:
            average_value2 = similar_rows2[column].mean()
            df.at[idx, column] = average_value2



#Para llenar missing de "Service" basado en la cantidad de teléfonos por cada 1000 personas
missing_service = df[df['Service'].isna()]

for idx, row in missing_service.iterrows():
    phone_value = row['Phones (per 1000)']

    similar_rows3 = df[(df['Phones (per 1000)'].notna()) & ((df['Phones (per 1000)'] - phone_value) < 0.5)]

    if not similar_rows3.empty:
        average_service = similar_rows3['Service'].mean()
        df.at[idx, 'Service'] = average_service

#Para llenar missing de "Industry" con el resto de Agriculture y Service
df['Industry'] = df['Industry'].fillna(1- df['Agriculture'] - df['Service'])

#Para llenar missing de "Arable (%)" con el resto de Crops (%) y Other (%)
df['Arable (%)'] = df['Arable (%)'].fillna(1- df['Crops (%)'] - df['Other (%)'])

#Para llenar NaN de observaciones que no pudieron ser imputadas de ninguna otra forma, con la moda de la región
columnas_a_llenar2 = ['Area (sq. mi.)', 'Pop. Density (per sq. mi.)','Coastline (coast/area ratio)', 'Net migration', 'Infant mortality (per 1000 births)',
 'GDP ($ per capita)', 'Literacy (%)', 'Phones (per 1000)', 'Arable (%)', 'Crops (%)', 'Other (%)', 'Climate', 'Birthrate', 'Deathrate', 'Agriculture', 'Industry', 'Service']

for columna in columnas_a_llenar2:
    for region in df['Region'].unique():
        #Moda de 'Climate' en cada región
        moda_reg = df[df['Region'] == region][columna].mode()

        #Rellenamos los NaN de esa región con la moda
        if not moda_reg.empty:
            df.loc[(df['Region'] == region) & (df[columna].isna()), columna] = moda_reg.iloc[0]

df[df.isnull().any(axis=1)]

"""---

Evaluando la base de datos, dado que ninguna variable presenta una proporción grande de valores nulos (missing), decidimos no eliminar ninguna columna. Porque a pesar de que climate que es la variable con mayor cantidad de valores nulos —20 nulos equivalente a 10% de las observaciones— se puede imputar por la región a la que pertenece el país y no representa problemas a la hora de realizar análisis posteriores.

Las imputaciones se hicieron basándonos en las variables con mayor correlación de las faltantes de la forma:

* `Birthrate` con la tasa de mortalidad infantil `Infant mortality` completandolo con el promedio de países con `Infant mortality` cercano.

* `Literacy (%)`, `Agriculture`, `Deathrate`, `Birthrate` correlacionan fuertemente con `Infant mortality` y se completó con el promedio de países con `Infant mortality` cercano.

* `Phones (per 1000)` y `Net migration` correlacionan fuertemente con `GDP per capita` y se rellenó con el promedio de países con un `GDP per capita` cercano (alrededor de $500).

* `Service` correlaciona fuertemente con `Phones (per 1000)` y se rellenó con el promedio de países con un promedio de `Phones (per 1000)` cercano.

A pesar de esto, hay 4 observaciones que no se han podido imputar completamente por la cantidad de missings y la baja correlación entre unas variables y otras. Estas fueron:

- La #85 (Guernsey) y #134 (Mayotte) que por falta de datos en `Arable(%)`, `Crops (%)` y `Other (%)` se optó por colocar la moda de `Crops (%)` y `Other (%)` para completar, dejando `Arable(%)` como un resto.

- La #221 (Wallis and Futuna) y la #223 (Western Sahara) por falta de datos principales no se pudieron completar otras variables importantes y se optó por colocar directamente la moda de la región para todos los missing restantes.


---

### Pregunta 1.9

¿Cómo distribuye el `GDP ($ per capita)` en diferentes **regiones**? Defina una forma ilustrativa de gráficar el `GDP ($ per capita)` para todas las regiones en un mismo gráfico. Interprételo.
"""

df["Region"] = df["Region"].str.strip() # quitar el espacio en blanco al final del nombre de las regiones
region = df["Region"]
pib = df["GDP ($ per capita)"]

sns.boxplot(y=region, x=pib, data=df)
plt.xticks(rotation=90)

"""---


Respecto a la distribución del PIB per cápita, destacan las regiones Norte América y Europa Occidental, con medianas cercanas a los 30,000 USD per cápita. En contraste, África Sub-Sahariana presenta un PIB per cápita mediano cercano a cero y valores atípicos bastante superiores, en torno a los 10,000 USD per cápita. Por otra parte, Latinoamérica y el Caribe presenta una distribución más amplia con países en niveles intermedios respecto a su ingreso per cápita. Por último, África del Norte y Asia (excluyendo el Cercano Oriente) presentan bajas medianas de PIB per cápita, pero con mayor dispersión.

Por otro lado, con respecto a los valores atípicos, destaca un país en la región de Europa Occidental, con un PIB per cápita que supera los 50,000 USD. Al revisar los datos, éste corresponde a Luxemburgo. Asimismo, regiones como Latinoamérica y el Caribe, Oceanía y Asia, presentan outliers bastante lejanos al PIB per cápita mediano de las regiones.

---

### Pregunta 1.10

Supongamos que `GDP ($ per capita)` es su variable objetivo. Estudie la correlación de esta variable con el resto de las variables del `df`. ¿Por qué es importante analizar la correlación entre las variables?
"""

#Utilizando la base de datos solo con las columnas númericas creada en la pregunta 1.8
Corr = round(numeric_df.corr()['GDP ($ per capita)'], 4)
corr_abs = Corr.abs() #Trabajamos con el valor absoluto de los valores
gdppc_sorted_corr = corr_abs.sort_values(ascending=False) #Organizamos en orden descendente
print(gdppc_sorted_corr)

"""---
Es relevante analizar la correlación del la variable objetivo y el resto de las variables, en este caso, PIB per cápita y características de los países, ya que nos ayuda a identificar variables que podrían ser predictores relevantes y que debiésemos incluir en nuestro modelo.

Por ejemplo, en el análisis previo, puede observarse que el número de teléfonos por cada 1,000 personas presenta una alta correlación con el PIB per cápita. Por lo tanto, si buscamos predecir el PIB per cápita, este análisis sugiere que la variable mencionada debe incluirse en el modelo.

---

### Pregunta 1.11

Realice tres _scatterplots_ (uno por variable) de las tres variables con la mayor correlación con la variable objetivo.

Utilizando los parámetros de la función con la que hizo los _scatterplots_, coloque un título a cada gráfico y agregue colores a los _data points_ del _scatterplot_- Use colores diferentes por cada gráfico.

---


Observando los resultados de la pregunta 1.10: Las tres variables con mayor correlación (en valor absoluto) son:


*   `phones (per 1000)`: el número de teléfonos (por 1000 personas) correlaciona fuerte y positivamente con el PIB per cápita.
*   `birthrate`: la tasa de natalidad correlaciona negativamente con el PIB per cápita.
*   `infant mortality (per 1000 births)`: mortalidad infantil (por 1000 nacimientos): el número de muertes infantiles por cada 1000 nacimientos correlaciona negativamente con el PIB per cápita



---
"""

#Definimos las variables y colores a utilizar
top_vars = ["Phones (per 1000)", "Birthrate", "Infant mortality (per 1000 births)"]
colores = ["blue", "green", "red"]

fig, axs = plt.subplots(1, 3, figsize=(17, 5)) #Ajustamos el tamaño y el orden

#Loop para crear los 3  gráficos
for i, var in enumerate(top_vars):
  sns.scatterplot(data=df, y="GDP ($ per capita)", x=var, ax=axs[i], color=colores[i])
  axs[i].set_title(f"Scatterplot de {var} vs. GDP per cápita", fontsize=9)
  axs[i].set_xlabel(var, fontsize=8)
  axs[i].set_ylabel("GDP per cápita", fontsize=8)

"""### Pregunta 1.12

Cree una nueva columna `GDP (%)` que represente el GDP total de cada pais (no per capita) y agreguela al dataframe.
"""

df["GDP ($)"] = df["Population"] * df["GDP ($ per capita)"]
numeric_df = df.select_dtypes(include=['number']) #Volvemos a correr este código para incluir GDP per capita en el df solo con datos númericos

"""### Pregunta 1.13

Repita el análisis de correlaciones para `GDP ($)` excluyendo `GDP ($ per capita)` del análisis. ¿Cambian las variables que más correlacionan? Justifique.
"""

Corr = round(numeric_df.corr()['GDP ($)'], 4)
Corr = Corr.drop('GDP ($ per capita)')
corr_abs = Corr.abs()
gdptotal_sorted_corr = corr_abs.sort_values(ascending=False)
print(gdptotal_sorted_corr)

"""---


Observando los resultados del análisis de correlaciones, efectivamente, las tres variables con mayor correlación (en valor absoluto) cambian. Con respecto al GDP en dólares, dichas variables corresponden a:

*   `population`: la población correlaciona fuerte y positivamente con el GDP.

*   `área (sq. mi.)`: la superficie del país correlaciona positivamente con el GDP.

*   `phones (per 1000)`: el número de teléfonos (por 1000 personas) correlaciona débil y positivamente con el GDP.


Cuando estudiamos la relación del GDP con las características de los países, las correlaciones difieren si consideramos el GDP en dólares, o en dólares per cápita. Esta diferencia corresponde a que representan medidas distintas: el GDP corresponde al tamaño absoluto de la economía, mientras que el GDP per cápita al tamaño relativo, sirviendo este último para realizar comparaciones más adecuadas entre países.

Por lo tanto, la diferencia en los resultados obtenidos es razonable. Por un lado, el GDP total suele estar fuertemente correlacionado con la población y superficie (área) del país, ya que los países más grandes suelen tener una economía más grande en términos absolutos. Mientras que el GDP per cápita representa la riqueza promedio por persona, lo que no depende directamente del tamaño de la población o el territorio del país. Esta última medida suele estar más relacionada con variables que miden el desarrollo humano, como por ejemplo, la alfabetización y la mortalidad infantil.

---

### Pregunta 1.14

Detecte las observaciones outliers de las tres variables seleccionadas en la pregunta anterior. Además, impute estas observaciones si usted lo considera necesario. Justifique su decisión.
"""

df2 = df.copy()
top_vars = ["Phones (per 1000)", "Population", "Area (sq. mi.)"]
colores = ["blue", "green", "red"]

# Definir qué será considerado un outlier a partir de un umbral que sea mayor a 2 desviaciones estándar
outlier_phone = df2["Phones (per 1000)"].mean() + (2 * df2["Phones (per 1000)"].std())
outlier_pop = df2["Population"].mean() + (2 * df2["Population"].std())
outlier_area = df2["Area (sq. mi.)"].mean() + (2 * df2["Area (sq. mi.)"].std())

thresholds = {
    "Phones (per 1000)": outlier_phone,  # Umbral para variable Phones (per 1000)
    "Population": outlier_pop,     # Umbral para Population
    "Area (sq. mi.)": outlier_area  # Umbral para Area (sq. mi.)
}

fig, axs = plt.subplots(1, 3, figsize=(17, 5))

#Crear los 3 scatterplots
for i, var in enumerate(top_vars):
    sns.scatterplot(data=df2, y="GDP ($ per capita)", x=var, ax=axs[i], color=colores[i])
    axs[i].set_title(f"Scatterplot de {var} vs. GDP per cápita", fontsize=9)
    axs[i].set_xlabel(var, fontsize=8)
    axs[i].set_ylabel("GDP per cápita", fontsize=8)

    threshold = thresholds.get(var, 0)
    high_values = df2[df2[var] > threshold]

    for _, row in high_values.iterrows():
        axs[i].annotate(f'{row["Country"]}', (row[var], row["GDP ($ per capita)"]),
                        textcoords="offset points", xytext=(0, 10), ha='center', fontsize=8, color='black')

plt.tight_layout()
plt.show()

#Eliminamos los outliers en una segunda base de datos llamada df2 para no alterar el df original
df2 = df2[(df2["Phones (per 1000)"]<outlier_phone) & (df2["Population"]<outlier_pop) & (df2["Area (sq. mi.)"]<outlier_area)]

"""---


Tomando en consideración que nuestra variable objetivo es el `GDP ($)`, tratar de desarrollar un modelo donde haya países que tengan 2 desviaciones estándar por encima del tamaño promedio de población y área, puede provocar una estimación imprecisa de las medidas, dado que, la mayor parte de los datos están concentrados alrededor de un umbral más acotado. Por este motivo, optamos por sacar de la muestra países que tengan 2 desviaciones por encima de la media de población y/o por encima de la media.

En el caso de `Phones (per 1000)` se decidió no editar las observaciones dentro de la muestra, a pesar de que existen múltiples registros que están 2 desviaciones estándar por encima de la media. Dado que tiene una correlación débil (menor al 25%) con `GDP ($)`, mantener la muestra invariable no debería ser perjudicial para la precisión del modelo. Así mismo, dado que esta variable cuenta con una dispersión (y desviación estándar) menor que las demás, aún contando con "outliers", se puede dar con una estimación precisa.

---

### Pregunta 1.15

En los ejemplos anteriores calculamos correlaciones para `GDP ($ per capita)` y `GDP ($)`. Genere un nuevo dataframe que tenga le variación porcentual de la correlación absoluta para cada una de las columnas de características, e.g., si la correlación en valor absoluto de `GDP ($ per capita)` vs `Industry` es 0.1 y la correlación `GDP ($)` vs `Industry` es 0.5, la variación deberá ser +500%. Dicha variación porcentual puede ser positiva o negativa, pero ordene los el dataframe de tal manera que la variación de correlación absoluta sea desendiente.
"""

numeric_df = df.select_dtypes(include=['number'])

Corr = round(numeric_df.corr()['GDP ($ per capita)'], 4)
corr_abs = Corr.abs()
df_corr = pd.DataFrame(corr_abs)

Corr2 = round(numeric_df.corr()['GDP ($)'], 4)
corr_abs2 = Corr2.abs()
df_corr['GDP ($)'] = pd.DataFrame(corr_abs2)

df_corr['Var (%)'] = (df_corr['GDP ($)']/df_corr['GDP ($ per capita)'])-1

df_corr = df_corr[(df_corr["GDP ($)"]!=1) & (df_corr["GDP ($ per capita)"]!=1)]

df_corr = df_corr.sort_values(by='Var (%)', ascending=False)

print(df_corr)

"""### Pregunta 1.16

Del resultado anterior, ¿qué caracerística del país tuvo una mayor diferencia absoluta el medir su correlación versus `GDP ($)` en vez de `GDP ($ per capita)`'. Interprete.

---



Al calcular la variación porcentual de la correlación absoluta, vemos que la característica del país que presenta una mayor diferencia absoluta es la población. Este resultado es razonable, ya que la población es una variable que tiene el efecto de escalar el PIB, ya que como podemos observar en los datos, los países con poblaciones más grandes tienden a ser economías más grandes (PIB total más alto). Por otra parte, cuando se calcula el PIB per cápita, se está “neutralizando” la población en dicho cálculo. Esto explicaría la relevancia que toma la variable población al compararse con el PIB total comparado con el PIB per cápita.

---

## EDA con diferentes fuentes de **información**

Una situación habitual en _Data Science: es el manejo de información de múltiples fuentes para un mismo propósito. En este sentido, de ahora en adelante agregaremos un dataframe adicional a nuestro set de información, disponible en [Github](https://raw.githubusercontent.com/datasets/gini-index/refs/heads/main/data/gini-index.csv). Lo llamaremos `df_gini`.

Este dataset contiene información histórica del Índice de Gini (economía), el cual captura la desigualdad económica entre los quintiles de cada país. A mayor índice Gini, más desigual es un país en términos de ingresos. Para mayor información sobre los datos, puede dirigirse al [Repositorio](https://github.com/datasets/gini-index) completo. Para conocer más sobre el índice, una navegación por [Wikipedia](https://en.wikipedia.org/wiki/Gini_coefficient) debería ser suficiente.

### Pregunta 2.0

Cargue la base datos, asegúrese de que la variable de año esté en un formato de "fecha", y usando el diccionario de mapeo por inconsistencias de nombres, `country_name_mapping`, encuentre la forma de realizar un INNER JOIN entre ambas tablas, usando el nombre del país y el año de la observación como variables por las cuales hacer el JOIN. En el diccionario `country_name_mapping`, _keys_ corresponden a los valores de la tabla `df_gini` y _values_ a los de `df`.

Llame al dataframe resultante `df_merged`.

Si usted no se ha percatado, los nombres en la columna `Country` de `df` poseen espacios al final de estos. Elimine los espacios antes de realizar el INNER JOIN de interés (Hint: existe una función propia de las variables tipo `string` que realiza la labor de eliminar espacios al final de la palabra).
"""

# NO MODIFICAR, pero sí ejecutar
country_name_mapping = {
    "Bahamas": "Bahamas, The",
    "Bosnia and Herzegovina": "Bosnia & Herzegovina",
    "Myanmar": "Burma",
    "Cabo Verde": "Cape Verde",
    "Central African Republic": "Central African Rep.",
    "Congo, Rep.": "Congo, Repub. of the",
    "Czechia": "Czech Republic",
    "Timor-Leste": "East Timor",
    "Egypt, Arab Rep.": "Egypt",
    "West Bank and Gaza": "Gaza Strip",
    "Iran, Islamic Rep.": "Iran",
    "Korea, Dem. People's Rep.": "Korea, North",
    "Korea, Rep.": "Korea, South",
    "Kyrgyz Republic": "Kyrgyzstan",
    "Lao PDR": "Laos",
    "North Macedonia": "Macedonia",
    "Micronesia, Fed. Sts.": "Micronesia, Fed. St.",
    "Russian Federation": "Russia",
    "St. Kitts and Nevis": "Saint Kitts & Nevis",
    "St. Lucia": "Saint Lucia",
    "St. Vincent and the Grenadines": "Saint Vincent and the Grenadines",
    "Slovak Republic": "Slovakia",
    "Eswatini": "Swaziland",
    "Syrian Arab Republic": "Syria",
    "Trinidad and Tobago": "Trinidad & Tobago",
    "Turkiye": "Turkey",
    "Venezuela, RB": "Venezuela",
    "Viet Nam": "Vietnam",
    "Yemen, Rep.": "Yemen"
}

df_gini = pd.read_csv("https://raw.githubusercontent.com/datasets/gini-index/refs/heads/main/data/gini-index.csv")

# Quitar espacios en blanco al final de los nombres
df["Country"] = df["Country"].str.strip()

# Formatear fecha en ambos df
df_gini["Year"] = pd.to_datetime(df_gini["Year"], format="%Y")
df['Year'] = pd.to_datetime(df['date'], format="%Y")

# Mapeo de nombres en df del índice de Gini
df_gini['Mapped Name'] = df_gini['Country Name'].replace(country_name_mapping)
df_gini = df_gini.rename(columns={"Mapped Name": "Country"})

# Merge de ambos df
df_merged = df_gini.merge(df, on=["Country", "Year"], how="inner")

df_merged = df_merged.drop(columns=['Country','Year'])

df_merged = df_merged.rename(columns={'Value': 'Gini'})

df_merged.head()

"""### Pregunta 2.1

Repita el ejercicio de la obtención de un ranking para las correlaciones absolutas, tal como lo hizo para el GDP per cápita. ¿Cuáles son las relaciones que más le sorprenden? ¿Cuáles son las que están en línea con lo que esperaba? Justifique para ambos casos.




"""

numeric_df = df_merged.select_dtypes(include=['number'])

Correl = round(numeric_df.corr()['Gini'], 4)
correl_abs = Correl.abs()
gini_corr = correl_abs.sort_values(ascending=False)

print(gini_corr)

"""---

En línea con lo esperado, la cantidad de `teléfonos` (por 1000 personas) tiene una correlación alta con el índice de Gini, que tal como el `PIB per capita`, refleja mejores condiciones económicas en los países y por ende una mayor correlación con el Gini.

Por otra parte, sorprende que un indicador como tasa de nacimientos (`Birthrate`) se asocie fuertemente con los niveles de desigualdad medidos por el índice de Gini, dado que la tasa de nacimientos a priori no pensariamos ayuda a explicar que tan desigual es un país.

Para este análisis no hemos considerado la variable de `clima` dado que analizando la base de datos, se puede notar que es una variable categórica entre 1 y 4, probablemente reflejando 4 tipos de climas distintos, más no cuenta con una interpretación lógica para una correlación.

---

Finalmente, agregaremos una tercera base de datos al análisis, también disponible en [Github](https://raw.githubusercontent.com/datasets/co2-fossil-by-nation/refs/heads/main/data/fossil-fuel-co2-emissions-by-nation.csv) con su repectivo
[Repositorio](https://github.com/datasets/co2-fossil-by-nation). Esta contiene emisiones de dióxido de carbono (CO2) total y por fuentes, desagregado por país. La base de datos contiene datos desde el siglo XVI y la frecuencia es anual.

### Pregunta 2.2

Cargue la base de datos llamándola `df_co2`. Asegúrese de que todas las variables estén en su correcto formato (años deben estar en un formato de fecha). ¿Qué cuidados identifica usted que debiésemos tener al momento de observar valores nulos en esta base de datos?

Adicionalmente, para cada palabra en la columna `Country`, asegúrese de que la primera letra siempre sea mayúscula y que el resto de letras sean minúsculas (Hint: revise `methods` propios de las variables tipo `string`).

Luego, reemplace valores en `df_co2["Country"]` según el mapping otorgado. En el diccionario `country_name_mapping_co2`, _keys_ corresponden a los valores de la tabla `df_co2` y _values_ a los de `df`.
"""

# NO MODIFICAR, pero sí ejecutar
country_name_mapping_co2 = {
    "United States Of America": "United States",
    "France (Including Monaco)": "France",
    "Italy (Including San Marino)": "Italy",
    "Plurinational State Of Bolivia": "Bolivia",
    "Federal Republic Of Germany": "Germany",
    "Former German Democratic Republic": "Germany",
    "Republic Of Moldova": "Moldova",
    "United Republic Of Tanzania": "Tanzania",
    "Japan (Excluding The Ruyuku Islands)": "Japan",
    "Hong Kong Special Adminstrative Region Of China": "Hong Kong",
    "Peninsular Malaysia": "Malaysia",
    "Democratic Republic Of The Congo (Formerly Zaire)": "Congo, Dem. Rep.",
    "Brunei (Darussalam)": "Brunei",
    "Myanmar (Formerly Burma)": "Burma",
    "Syrian Arab Republic": "Syria",
    "Islamic Republic Of Iran": "Iran",
    "Republic Of Korea": "Korea, South",
    "Democratic People S Republic Of Korea": "Korea, North",
    "Russian Federation": "Russia",
    "Viet Nam": "Vietnam",
    "Yemen": "Yemen, Rep.",
    "Trinidad And Tobago": "Trinidad & Tobago",
    "Bahamas": "Bahamas, The",
    "Micronesia": "Micronesia, Fed. St.",
    "Slovakia": "Slovakia",
    "St. Vincent & The Grenadines": "Saint Vincent and the Grenadines",
    "Saint Lucia": "Saint Lucia",
    "Antigua & Barbuda": "Antigua & Barbuda",
    "Saint Kitts-Nevis-Anguilla": "Saint Kitts & Nevis",
    "Netherland Antilles And Aruba": "Netherlands Antilles",
    "Timor-Leste (Formerly East Timor)": "East Timor",
    "Macau Special Adminstrative Region Of China": "Macau",
    "Republic Of Cameroon": "Cameroon",
    "Republic Of Sudan": "Sudan",
    "Lao People S Democratic Republic": "Laos",
    "Libyan Arab Jamahiriyah": "Libya",
    "Cote D Ivoire": "Cote d'Ivoire",
    "British Virgin Islands": "British Virgin Is.",
    "Faeroe Islands": "Faroe Islands",
    "China (Mainland)": "China",
}

df_co2 = pd.read_csv("https://raw.githubusercontent.com/datasets/co2-fossil-by-nation/refs/heads/main/data/fossil-fuel-co2-emissions-by-nation.csv")

#Ajustes de formatos
df_co2["Year"] = pd.to_datetime(df_co2["Year"], format="%Y")
df_co2["Country"] = df_co2["Country"].str.title()

#Cambiar paises con el mapping
df_co2['Mapped Name'] = df_co2['Country'].replace(country_name_mapping_co2)

#Imputar los missing
df_co2.isnull().sum().sort_values(ascending=False)/df_co2.shape[0]  #Porcentaje de missing en total

columnas= ['Liquid Fuel', 'Cement', 'Bunker fuels (Not in Total)']
for columna in columnas:
  df_co2[columna].fillna(df_co2[columna].mean(), inplace=True)

df_co2.isnull().sum().sort_values(ascending=False)/df_co2.shape[0]

"""---

Se optó por completar los missing solo de las variables `Liquid fuels`, `Cement` y `Bunker fuels` dado que tenían un porcentaje de missing relativamente bajo (menor de 5%), para poder recuperar variabilidad en la base de datos, utilizando la media para no afectar la propia distribución de la muestra.

---

### Pregunta 2.3

En un mismo gráfico, grafique las series de emisiones totales de CO2 para los siguientes países:

- Reino Unido
- Canadá
- Alemania
- Francia
- Estados Unidos
- Brasil
- China
- Japón
- India


Para cada serie, añada una leyenda con el nombre del país.
"""

#Definimos los países a utilizar y nos quedamos con un df que solo los incluya
paises = ['United Kingdom', 'Canada', 'Germany', 'France', 'United States', 'Brazil', 'China', 'Japan', 'India']
df_graph = df_co2[df_co2['Country'].isin(paises)]

plt.figure(figsize=(10, 6))

for country in paises:
    paises_data = df_graph[df_graph['Country'] == country]
    plt.plot(paises_data['Year'], paises_data['Total'], label=country)

plt.title("Evolución emisiones CO2")
plt.xlabel("Año")
plt.ylabel("CO2")
plt.legend()
plt.grid(False)
plt.tight_layout()
plt.show()

"""### Pregunta 2.4

Para el año 2007, por cada país realice un ranking de las fuentes con más emisiones de CO2 excluyendo las variables `Per Capita` y `Bunker fuels (Not in Total)`. Es decir, asigne un número de 1 a 5 a $\{$ `Solid Fuel`, `Liquid Fuel`, `Gas Fuel`, `Cement`, `Gas Flaring` $\}$, donde 1 es la mayor fuente de emisión de ese país en aquel año, y 5 indica que fue la menor; así para todos los países.

Si en 2007 no se reporta una fuente de emisión para un país, por ejemplo, si emisiones de `Gas Flaring` no se reportara, entonces asigne números de 1 a 4 a las fuentes restantes. Análogo para un menor número de datos.

Luego, por cada variable grafique un histograma de frecuencias del ranking que obtuvo la fuente emisión a lo largo de todos los países.

¿Cuál fue la fuente más contaminante en la mayoría de países en 2007?

"""

#Duplicamos el df para no alterar el df original y eliminamos las columnas que no se utilizarán
df_4 = df_co2.copy()
df_4 = df_4.drop(columns=['Per Capita', 'Bunker fuels (Not in Total)'])
df_4 = df_4[df_4['Year'] == pd.to_datetime('2007-01-01')]

#Ranking de fuentes de emisiones
fuentes = ['Solid Fuel', 'Liquid Fuel', 'Gas Fuel', 'Cement', 'Gas Flaring']
df_ranks = df_4[fuentes].rank(axis=1, ascending=False, method='min')

#Histogramas
plt.figure(figsize=(15, 10))

for i, col in enumerate(fuentes):
    plt.subplot(2, 3, i+1)
    plt.hist(df_ranks[col], bins=20, color='skyblue', edgecolor='black')
    plt.title(f'{col}')
    plt.xlabel('Ranking')
    plt.ylabel('Frecuencia')

plt.tight_layout()
plt.show()

"""---


Como se puede ver en los histogramas, el combustible que en más ocasiones quedó como el número 1 fue `Liquid Fuels`, donde para 160 países fue la fuente de mayor emisiones de CO2.

---

### Pregunta 2.5

Para cada serie de total de emisiones por país, calcule el cambio porcentual a través del tiempo. Realice imputación de missings si considera necesario, justificando su imputación. Si no lo considera necesario, también justifique (se evaluará un buen criterio fundamentado).

Repita el ejercicio del gráfico de series de tiempo anterior, pero graficando los **cambios porcentuales** para años mayores o iguales a 1995. ¿Cómo interpretaría económicamente el shock sobre las emisiones de CO2 tanto en la crisis subprime como en la crisis del Covid-19?
"""

#Calcular crecimiento
df_plot = df_co2.sort_values(by=['Country', 'Year'])
df_plot['CO2 % Change'] = df_plot.groupby('Country')['Total'].pct_change() * 100
df_plot= df_plot[df_plot['Year'] >= pd.to_datetime('1995-01-01')]

#Calcular los missing
df_plot.isnull().sum().sort_values(ascending=False)/df_plot.shape[0]

#Definir lista de países
paises = ['United Kingdom', 'Canada', 'Germany', 'France', 'United States', 'Brazil', 'China', 'Japan', 'India']

#Graficar países
df_plot = df_plot[df_plot['Country'].isin(paises)]

plt.figure(figsize=(10, 6))

for country in paises:
    country_data = df_plot[df_plot['Country'] == country]
    plt.plot(country_data['Year'], country_data['CO2 % Change'], label=country)

plt.title("Variación CO2 en el tiempo")
plt.xlabel("Año")
plt.ylabel("Var. porcentual (%)")
plt.axhline(0, color='gray', linestyle='--', linewidth=1)
plt.legend()
plt.grid(False)
plt.tight_layout()
plt.show()

"""---


Dado que los missing que existen en la base son para países que no iban a ser graficados (por ej. Mayotte, Reunion, etc) y para pocas fechas, se ha optado por no imputar ningún missing y mantener la base de datos igual.

A diferencia de otros períodos donde hay incrementos y caídas para múltiples países, tanto la crisis sub-prime en 2009 como la pandemia por covid-19 en 2020, provocaron una caída cercana al 10% interanual en las emisiones de CO2 para **todos** los países representados en el gráfico. Esto se ve bastante relacionado con lo sucedido a nivel económico, donde ambos eventos generaron recesiones económicas en estos países (aunque de magnitudes menores).

---

### Pregunta 2.6

Calcule el promedio a lo largo de toda la muestra ($\mathbb{E}[\cdot]$) para el cambio porcentual de cada país y genere una nueva serie con la resta entre el cambio porcentual del país $i$ en el año $t$, y el promedio del cambio porcentual del país $i$. En otras palabras, genere una serie con _**desvíos del cambio porcentual promedio**_ $\forall i,t$:

$$Nueva Serie_i = \Delta \% TotalCO2_{i,t} - \mathbb{E}[{\Delta \% TotalCO2_{i,t}}]$$

Luego, para los siguientes países:

- Reino Unido
- Canadá
- Alemania
- Francia
- Estados Unidos
- Japón
- Italia
- España


grafique en un panel _1x2_ la desviación del cambio porcentual respecto al promedio entre 2007 y 2010 en lado izquierdo, y entre 2017 y 2020 en el lado derecho (Hint: Hay comandos que facilitan esta labor. Puede intentar con `fig, axes = plt.subplots(1, 2, figsize=(18, 6), sharey=True)`, por ejemplo).

¿Existe algún país en particular que mostró mayores desviaciones atípicas de emisión de CO2 durante el periodo de la crisis sub-prime? ¿Cómo es el comportamiento de las desviaciones atípicas de CO2 de este país durante la crisis del Covid-19?
"""

# Ordenar dataframe por país y año
df_co2 = df_co2.sort_values(['Country', 'Year'])

# Calcular cambio % de las emisiones totales (Total) para cada país, año a año
df_co2['Cambio % de emisiones'] = df_co2.groupby('Country')['Total'].pct_change() * 100

# Calcular promedio de las variaciones % para cada país
df_co2['Cambio % promedio de emisiones'] = df_co2.groupby('Country')['Cambio % de emisiones'].transform('mean')

# Calcular desviación de la variación % de cada año respecto al promedio del país
df_co2['Desvío del cambio % promedio'] = df_co2['Cambio % de emisiones'] - df_co2['Cambio % promedio de emisiones']

# Lista de países
paises6 = ['United Kingdom', 'Canada', 'Germany', 'France', 'United States', 'Japan', 'Italy', 'Spain']

# Filtrar los países
df_filtrado = df_co2[df_co2['Country'].isin(paises6)]

# Filtrar los dos períodos
df_subprime = df_filtrado[df_filtrado['Year'].between(pd.Timestamp('2007-01-01'), pd.Timestamp('2010-12-31'))]
df_covid = df_filtrado[df_filtrado['Year'].between(pd.Timestamp('2017-01-01'), pd.Timestamp('2020-12-31'))]

# Gráfico en panel 1x2
fig, axes = plt.subplots(1, 2, figsize=(18, 6), sharey=True)

for country in paises6:
    df_country_subprime = df_subprime[df_subprime['Country'] == country]
    df_country_covid = df_covid[df_covid['Country'] == country]

    axes[0].plot(df_country_subprime['Year'], df_country_subprime['Desvío del cambio % promedio'], label=country)
    axes[1].plot(df_country_covid['Year'], df_country_covid['Desvío del cambio % promedio'], label=country)

# Títulos y etiquetas
axes[0].set_title('Desviación CO2 (2007–2010): Crisis Sub-prime')
axes[0].set_xlabel('Año')
axes[0].set_ylabel('Desviación del Cambio %')
axes[0].legend()

axes[1].set_title('Desviación CO2 (2017–2020): Crisis Covid-19')
axes[1].set_xlabel('Año')

plt.tight_layout()
plt.show()

"""---


Es posible observar que de la muestra de países analizados, Alemania presenta una gran desviación atípica en la variación porcentual de emisiones de CO2, tanto en el periodo de la crisis sub-prime, como en la crisis por Covid-19, de en torno a un 400%. En contraste, el resto de los países casi no observan grandes cambios en ésta medida. Para dichos países, las desviaciones de las variaciones porcentuales de emisiones promedio de los países se mueven en un rango de entre 0 a -20% aproximadamente, presentando un comportamiento similar en ambas crisis.

En otras palabras, de la muestra de países, sólo Alemania presenta una fuerte caída en la variación porcentual de emisiones anuales.


---

### Pregunta 2.7

Genere un nuevo dataframe llamado `df_final`. Para esto, realice un INNER JOIN entre el dataframe `df_co2` y `df_merged` por "año y país" (debería terminar sólo con valores de 2007 si usted realiza un INNER JOIN).

Finalmente, grafique un mapa de calor de correlaciones (_heatmapt_) entre las variables numéricas ,excluyendo fechas.

¿Qué variables económicas, demográficas y de desarrollo humano muestran relación más importante con las emisiones de CO2? Interprete estas relaciones.
"""

#Ajustamos los nombres en la base de CO2 para poder hacer el merge con el df_merged
df_co2 = df_co2.rename(columns={"Mapped Name": "Country Name"})
df_co2 = df_co2.rename(columns={"Year": "date"})

df_final = df_merged.merge(df_co2, on=["Country Name", "date"], how="inner")

#Crear el heatmap
numeric_df = df_final.select_dtypes(include=['number'])

corr = numeric_df.corr()
plt.figure(figsize=(10, 8))
sns.heatmap(corr, annot=False, cmap='coolwarm', fmt=".2f", square=True)
plt.title("Heatmap de correlaciones")
plt.tight_layout()
plt.show()

#print(df_final)

"""---


Las principales variables relacionadas con emisiones de CO2 son:

* `Población`: Países con una población mayor tienden a generar mayor cantidad de CO2 por la mayor demanda de energía.

* `Area`: Países con una mayor extensión territorial por igual, tienen una mayor demanda energética para conectar y desarrollar las distintas zonas más alejadas del país.

* `PIB ($)`: Así como hemos visto previamente, el gráfico muestra que existe una correlación entre PIB ($) y emisiones de CO2, dado que países con un mayor producto (por más desarrollo o mayor población) tienden a generar mayores emisiones de CO2 total.

* En menor medida, otras variables que ya hemos expuesto que correlacionan positivamente con el PIB como son `PIB per capita`, `teléfonos` y `Migración neta` también presentan una correlación relativamente alta con la emisión de CO2.



---

"""